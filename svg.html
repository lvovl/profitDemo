<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>WoW！</title>
<link rel="stylesheet" type="text/css" href="style.css">
<script src="circleBorder.js"></script>
<script src="svgCircle.js"></script>
<script src="particleBackground.js"></script>
<script src="loading.js"></script>
<style>
</style>
</head>
<body>

  <canvas id="circleCanvas" width="950" height="950"></canvas>
  <canvas id="canvasParticle"></canvas>
    <svg class="electric-loader" viewBox="0 0 100 100">
      <g></g>
    </svg>
    <svg id="circleBlue"></svg>
    <svg id="sideSvg">
    </svg>

    <div class="params">
      <p>
        <label for="σ">σ</label><input type="range" name="points" min="0" max="1" />
      </p>
      <p>
        <label for="cost">cost</label><input type="range" name="points" min="0" max="100" />
      </p>
    </div>
    <div class="heatmap">
      <a href="#map1" class="flink"></a>
      <a href="#map1" class="rlink"></a>
      <a href="#map1" class="plink"></a>

    </div>
</body>
<script src="d3.v4.min.js"></script>
<!--script src="simple-statistics.js"></script-->
<script>
const W = document.body.clientWidth;
const H = window.innerHeight;
const PrimaryColor = '#1f97ed'
const svg = d3.select('#circleBlue')
  .attr("width", W)
  .attr("height", H)
const sideSvg = d3.select('#sideSvg')
  .attr("width", W)
  .attr("height", H)
const lineA = d3.line().x(d=>d[0]).y(d=>d[1]);
const pointerData = [
  [[W*0.25,H*0.13],[W*0.33, H*0.13],[W*0.48,H*0.46]],
  [[W*0.25,H*0.78],[W*0.33, H*0.78],[W*0.49,H*0.59]],
  [[W*0.75,H*0.78],[W*0.62, H*0.79],[W*0.55,H*0.59]]
];
sideSvg.selectAll('.pointer').data(pointerData).enter().append('path').attr('class', 'pointer').attr('d', lineA)
</script>
<script src="statistic.js"></script>
<script src="centerDistribution.js"></script>
<script>
const centerCircle = () => {
  const r = 300
  svg.append("g").attr("id", "circle").attr("transform", `translate(${W * 0.5},${H * 0.5})`);
  const node = svg.select('#circle')
  node.append("circle").attr("cx", 0).attr("cy", 0).attr("stroke", PrimaryColor).attr("r", r).attr("stroke-width", 2).attr("fill", 'transparent')
  /*
  const arc = d3.arc()
    .innerRadius(n => (r + 5 * n + 5))
    .outerRadius(n => (r + 5 * n + 6))
    .startAngle(n => {
      return Math.PI / 20 * n
    })
    .endAngle(n => Math.PI / 10 * (n+1))
  node.selectAll('path').data(d3.range(0, 3)).enter().append("path").attr("d", arc).attr('fill', '#ccc')
  */
}
//沉没利润
const allowanceProfit = (m , n) => {
  var width = W*0.25;
  var height = H * 0.25;
  var xz = d3.range(m),
    yz = d3.range(n).map(() => bumps(m)),
    y01z = d3.stack().keys(d3.range(n))(d3.transpose(yz)),
    yMax = d3.max(yz, n => d3.max(n)),
    y1Max = d3.max(y01z, y => d3.max(y, d => d[1]));
  var x = d3.scaleBand()
    .domain(xz)
    .rangeRound([0, width])
    .padding(0.08);

  var y = d3.scaleLinear()
    .domain([0, y1Max])
    .range([height, 0]);

  var color = d3.scaleOrdinal()
    .domain(d3.range(n))
    .range(d3.schemeCategory20c);
  y.domain([0, y1Max]);
  const panel = sideSvg.append("g").attr("class", "allowanceProfit");
  panel.append("g")
    .attr("text-anchor", "start")
    .append('text')
    .attr("y", 20)
    .attr("x", 0)
    .text("Allowance Profit");
  var series = panel.append("g").attr("class", "allowanceProfitChart").selectAll(".series")
    .data(y01z)
    .enter().append("g")
    .attr("fill", function(d, i) { return color(i); });

  var rect = series.selectAll("rect")
    .data(function(d) { return d; })
    .enter().append("rect")
    .attr("x", function(d, i) { return x(i); })
    .attr("y", height)
    .attr("width", x.bandwidth())
    .attr("height", 0);

  rect.transition()
    .duration(500)
    .delay(function(d, i) { return i * 10; })
    .attr("y", function(d) { return y(d[1]); })
    .attr("height", function(d) { return y(d[0]) - y(d[1]); })
}

const distribE = (m) => {
  // var xz = d3.range(m),
  // yz = d3.range(n).map(() => bumps(m)),
  yMax = 10;// d3.max(yz, n => d3.max(n));
  const r = 300;
  const c = [1.1, 0.72, 2.05, 1.35, 2.4]

  const arc = d3.arc()
    .innerRadius((n,i) => (r + 10 * i + 5))
    .outerRadius((n,i) => (r + 10 * i + 7))
    .startAngle(0)
    .endAngle(n => Math.PI / 2 * n)
  const node = svg.select('#circle');

  const nodePath = node.selectAll('path').data(c).enter().append("path").attr('fill', PrimaryColor)

  const tweenArc = (b) => {
    return function(a, i) {
      var d = b.call(this, a, i);
      const m = d3.interpolate(0, d);
      //console.log(arc)
      // for (var k in d) a[k] = d[k]; // update data
      return function(t) { return arc(m(t), i); };
    };
  }
  nodePath.transition()
    .duration(500)
    .delay(function(d, i) { return i * 150; })
    .attrTween("d", tweenArc((d, i) => {
      return d;
    }))
  console.log('4');
    //.attrTween("d", arc([0,0,0,0,0]))
}
const pubOpMonitor = (m) => {
  var w = W * 0.25;
  var h = H * 0.15;
  var data = [1.3, 2.3, -1.5, -1.7, 1.5, 2.3, 1.9];
    yMax = d3.max(data);
  const dist = sideSvg.append("g").attr("transform", `translate(50,${H*0.7})`).attr("id", "pubop")
  const x = d3.scaleLinear().domain([0, data.length-1]).range([0, w])
  const y = d3.scaleLinear().domain([0, 3]).rangeRound([h, 0])
  const area = d3.area()
      .x((d,i) => x(i))
      .y0(h)
      .y1(d => y(d))
  const line = area.lineY1()
  dist.append("g").attr("text-anchor", "start")
    .append('text')
    .attr("y", 20)
    .attr("x", 0)
    .text("Public Opinion Monitor");
  dist.append("g").attr("text-anchor", "end")
    .attr('class', 'h1')
    .append('text')
    .attr("y", 20)
    .attr("x", w)
    .text("1.1");

  /*g.attr("text-anchor", "end")
    .append('text')
    .attr("y", 20)
    .attr("x", 0)
    .text("1.9");*/
  dist.append("path")
    .attr("d", area(data))
    .attr("fill", PrimaryColor)
    .attr('opacity', 0.1)
  dist.append("path")
    .attr("d", line(data))
    .attr("stroke", PrimaryColor)
    .attr("fill", 'none')
    .attr("stroke-width", 2)

}

//沉没利润
const valueAddedProfit = (m , n) => {
  var width = W*0.25;
  var height = H * 0.25;
  var xz = d3.range(m),
    yz = d3.range(n).map(() => bumps(m)),
    y01z = d3.stack().keys(d3.range(n))(d3.transpose(yz)),
    yMax = d3.max(yz, n => d3.max(n)),
    y1Max = d3.max(y01z, y => d3.max(y, d => d[1]));
  var x = d3.scaleBand()
    .domain(xz)
    .rangeRound([0, height-50])
    .padding(0.08);

  var y = d3.scaleLinear()
    .domain([0, y1Max])
    .range([height, 0]);

  var color = d3.scaleOrdinal()
    .domain(d3.range(n))
    .range(d3.schemeCategory20c);
  y.domain([0, y1Max]);
  
  const panel = sideSvg.append("g").attr("class", "valueAddedProfit").attr("transform", `translate(${W*0.75},${H*0.7})`);
  panel.append("g")
    .attr("text-anchor", "start")
    .append('text')
    .attr("y", 20)
    .attr("x", 0)
    .text("Value-added Profit");
  panel.append("g")
    .attr("text-anchor", "end")
    .append('text')
    .attr("y", 20)
    .attr("x", width)
    .text("27.4%");

  var series = panel.append("g").attr("class", "chart").selectAll("g")
    .data(y01z)
    .enter().append("g")
    .attr("fill", function(d, i) { return color(i); });
    console.log(series);
  var rect2 = series.selectAll("rect")
    .data(function(d) { return d; })
    .enter().append("rect")
    .attr("y", (d, i) => x(i))
    .attr("x", 20)
    .attr("width",  d=>(y(d[0]) - y(d[1])))
    .attr("height", x.bandwidth());
}


const price = 20.6, i = 0.05;

centerDistribution(price, i);//中间的分布图
centerCircle();//中间的圆圈
allowanceProfit(20, 2)//补贴发放和使用趋势
pubOpMonitor(20,2);//舆情监控的趋势
valueAddedProfit(5,1)//
// distribE(5);//中间描述补贴的分布环线
startCircleBorder();
startSvgCircle();
startParticleBackGround();
</script>
<script src="mousemove.js"></script>
</html>